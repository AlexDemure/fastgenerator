app:
  tree:
    src:
      clients: {}
      databases:
        postgres:
          crud: {}
          tables: {}
      domain:
        collections:
          enums: {}
          exceptions: {}
        models: {}
        repositories: {}
        services: {}
      endpoints:
        http:
          const:
            errors: {}
          deps: {}
          openapi: {}
          systemapi: {}
      framework: {}
      static:
        __init__.py: false
      storages: {}
      tools: {}
      utils: {}
    tests:
      factories:
        models: {}
        tables: {}
      mocking: {}
      test_integrations: {}
      test_loads: {}
      test_units: {}
  files:
    - path: ".gitignore"
      content: |
        .venv
        .env
        .mypy_cache
        .ruff_cache
        .pytest_cache
        __pycache__
    - path: "isort.cfg"
      content: |
        [settings]
        line_length = 120
        force_grid_wrap = 0
        multi_line_output = 3
        include_trailing_comma = true
        force_single_line = true
    - path: "ruff.toml"
      content: |
        exclude = [
          ".ruff_cache",
          ".venv",
          ".git",
          "__pycache__",
          ".pytest_cache",
          ".mypy_cache",
          "pyproject.toml"
        ]
        include = ["*.py"]
        respect-gitignore = true
        show-fixes = true
        line-length = 120
        indent-width = 4
        target-version = "py310"
    - path: "setup.cfg"
      content: |
        [mypy]
        ignore_missing_imports = True
        disable_error_code = var-annotated
        exclude = .git,__pycache__,.pytest_cache,.mypy_cache,.venv/
    - path: "format.sh"
      content: |
        isort src/
        ruff format src/ --no-cache
        radon cc . -a -nc
    - path: "cli.py"
      content: |
        import typer as typer
        import uvicorn as uvicorn
  
        app = typer.Typer()
  
        @app.command()
        def run(workers: int = 1):
            uvicorn.run(
                "src.framework.application:app",
                port=8000,
                host="0.0.0.0",
                workers=workers,
                app_dir="src",
            )
  
        if __name__ == "__main__":
            app()
    - path: ".env"
      content: |
        ENV=develop
        POSTGRES_HOST=postgresql+asyncpg://postgres:postgres@localhost:5432/db
        HTTP_BASIC_USERNAME=admin
        HTTP_BASIC_PASSWORD=admin
    - path: "docker-compose.yaml"
      content: |
        version: "3.8"
  
        volumes:
          .volumes:
  
        services:
          postgres:
            image: postgres:16
            container_name: postgres
            hostname: postgres
            restart: always
            ports:
              - "5432:5432"
            volumes:
              - .volumes/pgdata:/var/lib/postgresql/data
            environment:
              POSTGRES_USER: postgres
              POSTGRES_PASSWORD: postgres
              POSTGRES_HOST: localhost
              POSTGRES_PORT: 5432
              POSTGRES_DB: db
            command: ["postgres", "-c", "log_statement=all"]
    - path: "src/databases/postgres/migrations/env.py"
      content: |
        import asyncio
        from logging.config import fileConfig
  
        from alembic import context
        from sqlalchemy import engine_from_config
        from sqlalchemy import pool
        from sqlalchemy.ext.asyncio import AsyncEngine
  
        from src.databases.postgres import tables  # noqa:F401
        from src.databases.postgres.setup import Table
        from src.framework import settings
  
        # this is the Alembic Config object, which provides
        # access to the values within the .ini file in use.
        config = context.config
        config.set_main_option("sqlalchemy.url", settings.POSTGRES_HOST)
  
        # Interpret the config file for Python logging.
        # This line sets up loggers basically.
        if config.config_file_name is not None:
            fileConfig(config.config_file_name)
  
        # add your model's MetaData object here
        # for 'autogenerate' support
        # from myapp import mymodel
        # target_metadata = mymodel.Base.metadata
        target_metadata = Table.metadata
  
        # other values from the config, defined by the needs of env.py,
        # can be acquired:
        # my_important_option = config.get_main_option("my_important_option")
        # ... etc.
  
  
        def run_migrations_offline() -> None:
            """Run migrations in 'offline' mode.
  
            This configures the context with just a URL
            and not an Engine, though an Engine is acceptable
            here as well.  By skipping the Engine creation
            we don't even need a DBAPI to be available.
  
            Calls to context.execute() here emit the given string to the
            script output.
  
            """
            url = config.get_main_option("sqlalchemy.url")
            context.configure(
                url=url,
                target_metadata=target_metadata,
                literal_binds=True,
                dialect_opts={"paramstyle": "named"},
            )
  
            with context.begin_transaction():
                context.run_migrations()
  
  
        def do_run_migrations(connection):
            context.configure(connection=connection, target_metadata=target_metadata, compare_type=True)
  
            with context.begin_transaction():
                context.run_migrations()
  
  
        async def run_migrations_online():
            """Run migrations in 'online' mode.
  
            In this scenario we need to create an Engine
            and associate a connection with the context.
  
            """
            connectable = AsyncEngine(
                engine_from_config(
                    config.get_section(config.config_ini_section),
                    prefix="sqlalchemy.",
                    poolclass=pool.NullPool,
                    future=True,
                )
            )
  
            async with connectable.connect() as connection:
                await connection.run_sync(do_run_migrations)
  
  
        if context.is_offline_mode():
            run_migrations_offline()
        else:
            asyncio.run(run_migrations_online())

    - path: "src/databases/postgres/crud/__init__.py"
      content: |
        from .base import CRUD
    - path: "src/databases/postgres/crud/base.py"
      content: |
        from datetime import date
  
        from sqlalchemy import BinaryExpression
        from sqlalchemy import UnaryExpression
        from sqlalchemy import delete
        from sqlalchemy import exists
        from sqlalchemy.sql import asc
        from sqlalchemy.sql import desc
        from sqlalchemy import func
        from sqlalchemy import select
        from sqlalchemy import update
        from sqlalchemy.exc import NoResultFound
        from sqlalchemy.sql import Select
  
        from src.databases.exceptions import ObjectNotFoundError
        from src.databases.postgres.setup import AsyncSession
        from src.databases.postgres.tables import Table
  
  
        class CRUD:
            table: Table
  
            @classmethod
            def filters(cls, fields: dict) -> list[BinaryExpression]:
                expressions = []
  
                for key in fields.keys():
                    if fields[key] is not None:
                        if isinstance(fields[key], list):
                            expressions.append(getattr(cls.table, key).in_(fields[key]))
                        elif isinstance(fields[key], date):
                            expressions.append(func.DATE(getattr(cls.table, key)) == fields[key])
                        else:
                            expressions.append(getattr(cls.table, key) == fields[key])
  
                return expressions
  
            @classmethod
            async def one(cls, session: AsyncSession, **kwargs) -> Table:
                query = select(cls.table).where(*cls.filters(kwargs))
                return await fetchone(session, query)
  
            @classmethod
            async def relations(cls, session: AsyncSession, **kwargs) -> Table:
                query = select(cls.table).where(*cls.filters(kwargs))
                return await fetchone(session, query)
  
            @classmethod
            async def paginated(
                cls,
                session: AsyncSession,
                filters: dict,
                sorting: dict,
                pagination: dict,
            ) -> tuple[list[Table], int]:
                def prepare_filters() -> list[BinaryExpression]:
                    return []
  
                def prepare_sorting() -> list[UnaryExpression]:
                    field = sorting.get("field")
  
                    if field in ["id"]:
                        expression = getattr(cls.table, field)
                    else:
                        expression = cls.table.id
  
                    return (
                        [desc(expression)]
                        if sorting["type"] == "desc"
                        else [asc(expression)]
                    )
  
                def prepare_pagination() -> tuple[int, int]:
                    return pagination.get("limit", 10), pagination.get("offset", 0)
  
                filters = prepare_filters()
                sorting = prepare_sorting()
                limit, offset = prepare_pagination()
  
                query = select(cls.table).where(*filters).order_by(*sorting)
  
                rows = await fetchall(session, query.limit(limit).offset(offset))
                total = await count(session, query)
  
                return rows, total
  
            @classmethod
            async def all(cls, session: AsyncSession, **kwargs) -> list[Table]:
                query = select(cls.table).where(*cls.filters(kwargs))
                return await fetchall(session, query)
  
            @classmethod
            async def count(cls, session: AsyncSession, **kwargs) -> int:
                query = select(cls.table).where(*cls.filters(kwargs))
                return await count(session, query)
  
            @classmethod
            async def exists(cls, session: AsyncSession, **kwargs) -> bool:
                query = exists().where(*cls.filters(kwargs)).select()
                return (await session.execute(query)).scalar()
  
            @classmethod
            async def create(cls, session: AsyncSession, row: dict) -> Table:
                columns = {k: v for k, v in row.items() if getattr(cls.table, k, None) is not None}
                instance = cls.table(**columns)
                session.add(instance)
                await session.flush()
                return instance
  
            @classmethod
            async def update(cls, session: AsyncSession, id: str | int, **kwargs) -> None:
                columns = {k: v for k, v in kwargs.items() if getattr(cls.table, k, None) is not None}
                query = update(cls.table).where(cls.table.id == id).values(**columns)
                await session.execute(query)
                await session.flush()
  
            @classmethod
            async def delete(cls, session: AsyncSession, **kwargs) -> None:
                query = delete(cls.table).where(*cls.filters(kwargs))
                await session.execute(query)
                await session.flush()
  
  
        async def fetchone(session: AsyncSession, query: Select) -> Table:
            try:
                return (await session.execute(query)).unique().scalars().one()
            except NoResultFound:
                raise ObjectNotFoundError
  
  
        async def fetchall(session: AsyncSession, query: Select) -> list[Table]:
            return (await session.execute(query)).scalars().all()  # type:ignore
  
  
        async def count(session: AsyncSession, query: Select) -> int:
            return (await session.execute(select(func.count()).select_from(query.subquery()))).scalars().one()

    - path: "src/databases/postgres/tables/__init__.py"
      content: |
        from .base import Table
    - path: "src/databases/postgres/tables/base.py"
      content: |
        from typing import TypeVar
        
        from src.databases.postgres.setup import Table as _Table
        
        Table = TypeVar("Table", bound=_Table)
    - path: "src/databases/postgres/__init__.py"
      content: |
        from .crud import CRUD
        from .crud import *
        from .setup import AsyncSession as Session  # type:ignore
        from .setup import pgconnect
    - path: "src/databases/postgres/setup.py"
      content: |
        import enum
        import json
        from contextlib import asynccontextmanager
        from datetime import date
        from datetime import datetime
        from decimal import Decimal
        from functools import partial
  
        from sqlalchemy.ext.asyncio import AsyncSession
        from sqlalchemy.ext.asyncio import async_sessionmaker
        from sqlalchemy.ext.asyncio import create_async_engine
        from sqlalchemy.ext.declarative import declarative_base
  
        from src.framework import settings
  
  
        class DatetimeAwareJSONEncoder(json.JSONEncoder):
            def default(self, obj):
                if isinstance(obj, datetime):
                    return obj.isoformat()
                elif isinstance(obj, date):
                    return obj.isoformat()
                elif isinstance(obj, enum.Enum):
                    return obj.value
                elif isinstance(obj, Decimal):
                    return str(obj)
                try:
                    return json.JSONEncoder.default(self, obj)
                except TypeError:
                    return str(obj)
  
        custom_serializer = partial(json.dumps, cls=DatetimeAwareJSONEncoder, ensure_ascii=False)
  
  
        _engine = create_async_engine(
            settings.POSTGRES_HOST,
            echo=False,
            future=True,
            isolation_level="READ COMMITTED",
            json_serializer=custom_serializer,
        )
  
        _sessionmaker = async_sessionmaker(_engine, expire_on_commit=False)
  
        Table = declarative_base()
  
  
        @asynccontextmanager
        async def _read() -> AsyncSession:
            async with _sessionmaker() as session:
                await session.connection(execution_options={"isolation_level": "AUTOCOMMIT"})
                yield session
  
  
        @asynccontextmanager
        async def _write() -> AsyncSession:
            async with _sessionmaker() as session:
                try:
                    async with session.begin():
                        yield session
                except Exception as e:
                    await session.rollback()
                    raise e
  
  
        @asynccontextmanager
        async def pgconnect(transaction: bool = False) -> AsyncSession:
            if transaction:
                async with _write() as session:
                    yield session
            else:
                async with _read() as session:
                    yield session

    - path: "src/databases/__init__.py"
      content: |
        from .exceptions import ObjectNotFoundError
        from .orm import ORM
        from .sessions import Session
    - path: "src/databases/exceptions.py"
      content: |
        from src.tools.exceptions import Error
  
        class ObjectNotFoundError(Error):
            status_code = 404
    - path: "src/databases/orm.py"
      content: |
        from typing import TypeVar
        from typing import Union
  
        from src.databases import postgres
  
        ORM = TypeVar("ORM", bound=Union[postgres.CRUD])
    - path: "src/databases/sessions.py"
      content: |
        from typing import TypeVar
        from typing import Union
  
        from src.databases import postgres
  
        Session = TypeVar("Session", bound=Union[postgres.Session])
    - path: "src/domain/models/__init__.py"
      content: |
        from .base import Model
    - path: "src/domain/models/base.py"
      content: |
        from pydantic import BaseModel
        from pydantic import ConfigDict
  
        from src.databases.postgres.tables import Table
  
  
        class Model(BaseModel):
            model_config = ConfigDict(from_attributes=True, extra="allow")
  
            @classmethod
            def to_dict(cls, table: Table) -> dict:
                return {k: v for k, v in table.__dict__.items() if not k.startswith("_")}
  
            @classmethod
            def to_model(cls, table: Table) -> "Model":
                model = Model.model_validate(cls.to_dict(table))
  
                for key, value in model.model_extra.items():
                    if isinstance(value, Table.__bound__):
                        setattr(model, key, cls.to_model(value))
  
                return model
  
            @classmethod
            def from_orm(cls, table: Table) -> "Model":
                model = cls.model_validate(cls.to_dict(table))
  
                for key, value in model.model_extra.items():
                    if isinstance(value, Table.__bound__):
                        setattr(model, key, cls.to_model(value))
  
                return model
  
            @classmethod
            def init(cls, *args, **kwargs) -> dict:
                raise NotImplementedError
    - path: "src/domain/repositories/base.py"
      content: |
        from datetime import UTC
        from datetime import datetime
        from typing import Union
  
        from src.databases import ORM
        from src.databases import ObjectNotFoundError
        from src.databases import Session
        from src.domain.models import Model
        from src.tools.exceptions import Error
  
  
        class Repository:
            orm: ORM
            model: Model
            error: Error
  
            @classmethod
            async def one(cls, session: Session, **kwargs) -> "Repository.model":
                try:
                    row = await cls.orm.one(session, **kwargs)
                except ObjectNotFoundError:
                    raise cls.error
  
                return cls.model.from_orm(row)
  
            @classmethod
            async def relations(cls, session: Session, **kwargs) -> "Repository.model":
                try:
                    row = await cls.orm.relations(session, **kwargs)
                except ObjectNotFoundError:
                    raise cls.error
  
                return cls.model.from_orm(row)
  
            @classmethod
            async def paginated(
                cls,
                session: Session,
                filters: dict,
                sorting: dict,
                pagination: dict,
            ) -> tuple[list["Repository.model"], int]:
                rows, total = await cls.orm.paginated(session, filters, sorting, pagination)
                return [cls.model.from_orm(row) for row in rows], total
  
            @classmethod
            async def all(cls, session: Session, **kwargs) -> list["Repository.model"]:
                rows = await cls.orm.all(session, **kwargs)
                return [cls.model.from_orm(row) for row in rows]
  
            @classmethod
            async def count(cls, session: Session, **kwargs) -> int:
                return await cls.orm.count(session, **kwargs)
  
            @classmethod
            async def exists(cls, session: Session, **kwargs) -> bool:
                return await cls.orm.exists(session, **kwargs)
  
            @classmethod
            async def create(cls, session: Session, model: Model) -> "Repository.model":
                row = await cls.orm.create(session, row=model.dict())
                return cls.model.from_orm(row)
  
            @classmethod
            async def update(cls, session: Session, id: Union[str, int], **kwargs) -> None:
                await cls.orm.update(session=session, id=id, updated_at=datetime.now(UTC), **kwargs)
  
            @classmethod
            async def delete(cls, session: Session, **kwargs) -> None:
                return await cls.orm.delete(session, **kwargs)

    - path: "src/domain/__init__.py"
      content: |
        from .collections import enums
        from .collections import exceptions
    - path: "src/endpoints/http/const/errors/http.py"
      content: |
        from src.tools.exceptions import Error

        class Forbidden(Error):
            status_code = 403
    - path: "src/endpoints/http/const/tags.py"
      content: |
        PRIVATE = "ðŸ”"
        PUBLIC = "âšªï¸"
    - path: "src/endpoints/http/deps/security.py"
      content: |
        from typing import Annotated
  
        from fastapi import Depends
        from fastapi import HTTPException
        from fastapi import status
        from fastapi.security import HTTPBasic
        from fastapi.security import HTTPBasicCredentials
  
        from src.framework import settings
  
        def http_basic(credentials: Annotated[HTTPBasicCredentials, Depends(HTTPBasic())]) -> None:
            if not (
                (credentials.username == settings.HTTP_BASIC_USERNAME)
                and (credentials.password == settings.HTTP_BASIC_PASSWORD)
            ):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    headers={"WWW-Authenticate": "Basic"},
                )
    - path: "src/endpoints/http/deps/__init__.py"
      content: |
        from .security import http_basic
    - path: "src/endpoints/http/openapi/__init__.py"
      content: |
        from fastapi import APIRouter
        
        router = APIRouter()
    - path: "src/endpoints/http/systemapi/__init__.py"
      content: |
        from fastapi import APIRouter
  
        router = APIRouter()
    - path: "src/endpoints/http/__init__.py"
      content: |
        from fastapi import APIRouter
        from fastapi import Depends
        
        from src.endpoints.http import deps
        from src.endpoints.http.openapi import router as openapi
        from src.endpoints.http.systemapi import router as systemapi
        
        router = APIRouter(prefix="/api")
        
        router.include_router(openapi)
        router.include_router(systemapi, prefix="/-", dependencies=[Depends(deps.http_basic)])
    - path: "src/endpoints/http/schemas.py"
      content: |
        from typing import Any
        from typing import Self
        from typing import Union
  
        from pydantic import BaseModel
        from pydantic import conint
  
        from src.domain import models
  
  
        class ID(BaseModel):
            id: Union[int, str]
  
            @classmethod
            def serialize(cls, item: models.Model) -> Self:
                return cls(id=item.id)
  
  
        class Pagination(BaseModel):
            page: conint(gt=0, le=1000)
            size: conint(gt=0, le=100)
  
            @property
            def deserialize(self) -> dict:
                return dict(limit=self.size, offset=(self.page - 1) * self.size if self.page > 0 else 0)
  
  
        class Paginated(BaseModel):
            total: int
            items: list[Any]
    - path: "src/framework/settings.py"
      content: |
        from enum import StrEnum
        from enum import auto
  
        from pydantic_settings import BaseSettings
        from pydantic_settings import SettingsConfigDict
  
  
        class Env(StrEnum):
            develop = auto()
            production = auto()
  
  
        class PostgresSettings(BaseSettings):
            POSTGRES_HOST: str
        
        
        class AuthSettings(BaseSettings):
            HTTP_BASIC_USERNAME: str
            HTTP_BASIC_PASSWORD: str
  
        # INCLUDE SETTINGS
        configs = [
            PostgresSettings,
            AuthSettings,
        ]
  
        class Settings(*configs):  # type:ignore
            model_config = SettingsConfigDict(env_file=".env", case_sensitive=True, extra="ignore")
  
            ENV: Env
  
        settings = Settings()
    - path: "src/framework/application.py"
      content: |
        from contextlib import asynccontextmanager
  
        from fastapi import FastAPI
        from fastapi import Request
        from fastapi.middleware.cors import CORSMiddleware
        from fastapi.openapi.docs import get_redoc_html
        from fastapi.openapi.docs import get_swagger_ui_html
        from fastapi.openapi.utils import get_openapi
        from fastapi.responses import JSONResponse
        from fastapi.staticfiles import StaticFiles
  
        from src.endpoints.http import router
        from src.tools.exceptions import Error
  
  
        @asynccontextmanager
        async def lifespan(_: FastAPI):
            yield
  
  
        app = FastAPI(
            lifespan=lifespan,
            docs_url=None,
            redoc_url=None,
        )
  
  
        @app.get(
            "/api/docs",
            include_in_schema=False,
        )
        async def swagger():
            return get_swagger_ui_html(openapi_url="/api/openapi.json", title=app.title)
  
  
        @app.get(
            "/api/redoc",
            include_in_schema=False,
        )
        async def redoc():
            return get_redoc_html(openapi_url="/api/openapi.json", title=app.title)
  
  
        @app.get(
            "/api/openapi.json",
            include_in_schema=False,
        )
        async def openapi():
            return get_openapi(title=app.title, version=app.version, routes=app.routes)
  
  
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
  
  
        app.include_router(router)
  
        app.mount("/api/static", StaticFiles(directory="src/static"), name="static")
  
        @app.exception_handler(Error)
        async def error_handler(_: Request, error: Error) -> JSONResponse:
            return JSONResponse(status_code=error.status_code, content=error.to_dict())
    - path: "src/framework/__init__.py"
      content: |
        from .settings import Env
        from .settings import settings
    - path: "src/tools/exceptions/__init__.py"
      content: |
        from .base import Error
        from .utils import errors_to_swagger
    - path: "src/tools/exceptions/base.py"
      content: |
        class Error(Exception):
          status_code: int = 418
        
          def to_dict(self) -> dict:
            return dict(
              status_code=self.status_code,
              detail=dict(type=self.__class__.__name__),
            )
    - path: "src/tools/exceptions/utils.py"
      content: |
        def errors_to_swagger(*args) -> dict:
          responses = dict()
        
          error_codes = dict()
        
          errors = []
        
          for arg in args:
            error_codes[arg.status_code] = []
            errors.append(arg())
        
          for error in errors:
            error_codes[error.status_code].append(error.to_dict())
        
          for error in errors:
            examples = error_codes[error.status_code]
            example = examples if len(examples) > 1 else examples[0]
            responses[error.status_code] = dict(content={"application/json": {"example": example}})
        
          return responses
    - path: "src/utils/dates.py"
      content: |
        from datetime import UTC
        from datetime import date
        from datetime import datetime
  
  
        def now() -> datetime:
            return datetime.now(UTC)
  
  
        def midnight() -> datetime:
            return now().replace(hour=0, minute=0, second=0, microsecond=0)
  
  
        def today() -> date:
            return now().date()
    - path: "src/utils/strings.py"
      content: |
        def to_clean(string: str | None) -> str | None:
            return string.strip() if string else None
  
  
        def to_lower(string: str | None) -> str | None:
            return to_clean(string).lower() if string else None
  
  
        def to_upper(string: str | None) -> str | None:
            return to_clean(string).upper() if string else None
  
  
        def to_title(string: str | None) -> str | None:
            return to_clean(string).title() if string else None
  
  
        def to_capitalize(string: str | None) -> str | None:
            return to_clean(string).capitalize() if string else None
    - path: "tests/conftest.py"
      content: |
        import asyncio
        from typing import Iterator
        
        import pytest
  
        @pytest.fixture(scope="package")
        def event_loop() -> Iterator[asyncio.AbstractEventLoop]:
            loop = asyncio.new_event_loop()
            yield loop
            loop.close()
    - path: "tests/factories/models/base.py"
      content: |
        import factory
  
        class Table(factory.alchemy.SQLAlchemyModelFactory):
            class Meta:
                abstract = True
                sqlalchemy_session = None
                sqlalchemy_session_persistence = "flush"
    - path: "tests/test_integrations/conftest.py"
      content: |
        from contextlib import asynccontextmanager
        from typing import AsyncGenerator
  
        import pytest
        from api import router
        from fastapi import FastAPI
        from httpx import ASGITransport, AsyncClient
        from models.base import Base
        from settings import settings
        from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine
        from sqlalchemy.ext.asyncio.session import AsyncSession
        from sqlalchemy.orm import sessionmaker as _sessionmaker
  
  
        @pytest.fixture(scope="package", autouse=True)
        def engine() -> AsyncEngine:
            return create_async_engine(settings.DATABASE_URL, echo=True)
  
  
        @pytest.fixture(scope="package", autouse=True)
        async def db(engine):
            async with engine.begin() as conn:
                try:
                    await conn.run_sync(Base.metadata.drop_all)
                except Exception:
                    ...
  
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
  
            yield
  
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.drop_all)
  
  
        @pytest.fixture(scope="package", autouse=True)
        async def sessionmaker(engine):
            return _sessionmaker(engine, class_=AsyncSession, expire_on_commit=False, autoflush=True)
  
  
        @pytest.fixture(scope="function")
        async def session(engine, sessionmaker):
            async with sessionmaker() as _session:
                try:
                    yield _session
                finally:
                    await _session.rollback()
  
            await engine.dispose()
  
  
        @pytest.fixture(scope="function", autouse=True)
        def factories(session):
            for model in FACTORY_MODELS:
                model._meta.sqlalchemy_session = session
            yield
  
  
        @asynccontextmanager
        async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
            yield
  
  
        @pytest.fixture(scope="function")
        async def client(session):
            app = FastAPI(lifespan=lifespan)
  
            app.include_router(router)
  
            async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
                yield client





module:
  files:
    - path: "src/endpoints/http/openapi/${snake}/routers.py"
      content: |
        from fastapi import APIRouter
        from fastapi import Body
        from fastapi import Path
        from fastapi import status

        from src.domain import exceptions
        from src.domain import services
        from src.endpoints.http.const import tags
        from src.tools.exceptions import errors_to_swagger

        from .schemas import Search
        from .schemas import ${pascal}
        from .schemas import ${pascal}s

        router = APIRouter()

        @router.get(
          "/${kebab}:{id:int}",
          summary=tags.PUBLIC,
          status_code=status.HTTP_200_OK,
          response_model=${pascal},
          responses=errors_to_swagger(exceptions.${pascal}NotFoundError)
        )
        async def get(${snake}_id: int = Path(..., ge=1, alias="id")) -> ${pascal}:
            ${snake} = await services.${pascal}.page(${snake}_id)
            return ${pascal}.serialize(${snake})

        @router.get(
          "/${kebab}:{id:int}",
          summary=tags.PUBLIC,
          status_code=status.HTTP_200_OK,
          response_model=bool,
          responses=errors_to_swagger(exceptions.${pascal}NotFoundError)
        )
        async def exists(${snake}_id: int = Path(..., ge=1, alias="id")) -> bool:
            return await services.${pascal}.exists(${snake}_id)

        @router.post(
            "/${kebab}:search",
            summary=tags.PUBLIC,
            status_code=status.HTTP_200_OK,
            response_model=${pascal}s,
        )
        async def search(body: Search = Body(...)) -> ${pascal}s:
            ${snake}s, total = await services.${pascal}.search(**body.deserialize())
            return ${pascal}s.serialize(${snake}s, total)

    - path: "src/endpoints/http/systemapi/${snake}/routers.py"
      content: |
        from fastapi import APIRouter
        from fastapi import Body
        from fastapi import Depends
        from fastapi import Path
        from fastapi import status
        from fastapi import Response

        from src.domain import exceptions
        from src.domain import services
        from src.endpoints.http.const import tags
        from src.endpoints.http.schemas import ID
        from src.tools.exceptions import errors_to_swagger

        from .schemas import ${pascal}
        from .schemas import Create${pascal}
        from .schemas import Update${pascal}

        router = APIRouter()

        @router.post(
            "/${kebab}",
            summary=tags.PRIVATE,
            status_code=status.HTTP_201_CREATED,
            response_model=ID,
            responses={
                status.HTTP_401_UNAUTHORIZED: {},
                **errors_to_swagger(exceptions.${pascal}NotFoundError),
            },
        )
        async def create(body: Create${pascal} = Body(...)) -> ID:
            ${snake} = await services.${pascal}.create(${snake}_id=body.id)
            return ID.serialize(${snake})

        @router.get(
            "/${kebab}:{id:int}",
            summary=tags.PRIVATE,
            status_code=status.HTTP_200_OK,
            response_model=${pascal},
            responses={
                status.HTTP_401_UNAUTHORIZED: {},
                **errors_to_swagger(exceptions.${pascal}NotFoundError),
            },
        )
        async def get(${snake}_id: int = Path(..., ge=1, alias="id")) -> ${pascal}:
            return await services.${pascal}.page(${snake}_id)

        @router.put(
            "/${kebab}:{id:int}",
            summary=tags.PRIVATE,
            status_code=status.HTTP_204_NO_CONTENT,
            response_class=Response,
            responses={
                status.HTTP_401_UNAUTHORIZED: {},
                **errors_to_swagger(exceptions.${pascal}NotFoundError),
            },
        )
        async def update(body: Update${pascal} = Body(...)) -> None:
            await services.${pascal}.update(**body.dict())

        @router.delete(
            "/${kebab}:{id:int}",
            summary=tags.PRIVATE,
            status_code=status.HTTP_204_NO_CONTENT,
            response_class=Response,
            responses={
                status.HTTP_401_UNAUTHORIZED: {},
                **errors_to_swagger(exceptions.${pascal}NotFoundError),
            },
        )
        async def delete(${snake}_id: int = Path(..., ge=1, alias="id")) -> None:
            return await services.${pascal}.delete(${snake}_id)

    - path: "src/endpoints/http/openapi/${snake}/schemas.py"
      content: |
        from typing import Literal
        from typing import Self
        
        from pydantic import BaseModel
        from pydantic import conint
        
        from src.domain import models
        from src.endpoints.http.schemas import Paginated
        from src.endpoints.http.schemas import Pagination
        
        class Search(BaseModel):
            class Filter(BaseModel):
                ...
        
            class Sorting(BaseModel):
                field: Literal["id"]
                type: Literal["asc", "desc"]
        
            filters: Filter
            sorting: Sorting
            pagination: Pagination
        
            def deserialize(self) -> dict:
                return dict(
                    filters=dict(self.filters),
                    sorting=dict(self.sorting),
                    pagination=self.pagination.deserialize,
                )
        
        class ${pascal}(BaseModel):
            id: int
        
            @classmethod
            def serialize(cls, model: models.${pascal}) -> Self:
                return cls(id=model.id)
        
        class ${pascal}s(Paginated):
            items: list[${pascal}]
        
            @classmethod
            def serialize(cls, models: list[models.${pascal}], total: int) -> Self:
                return cls(items=[${pascal}.serialize(model) for model in models], total=total)
    - path: "src/endpoints/http/systemapi/${snake}/schemas.py"
      content: |
        from pydantic import BaseModel

        from src.domain import models

        class Create${pascal}(BaseModel):
            id: int

        class Update${pascal}(BaseModel):
            id: int

        class ${pascal}(models.${pascal}):
            ...

    - path: "src/endpoints/http/openapi/${snake}/__init__.py"
      content: |
        from .routers import router
    - path: "src/endpoints/http/systemapi/${snake}/__init__.py"
      content: |
        from .routers import router
    - path: "src/endpoints/http/openapi/__init__.py"
      content: |
        from .${snake} import router as ${snake}_router

        router.include_router(${snake}_router, tags=["${pascal}"])
    - path: "src/endpoints/http/systemapi/__init__.py"
      content: |
        from .${snake} import router as ${snake}_router

        router.include_router(${snake}_router, tags=["${pascal}"])
    - path: "src/domain/collections/exceptions/${snake}.py"
      content: |
        from src.tools.exceptions import Error

        class ${pascal}NotFoundError(Error): ...
    - path: "src/domain/collections/exceptions/__init__.py"
      content: |
        from .${snake} import *
    - path: "src/domain/models/${snake}.py"
      content: |
        from typing import Self

        from .base import Model

        class ${pascal}(Model):
            id: int

            @classmethod
            def init(cls, id: int) -> Self:
                return cls(id=id)
    - path: "src/domain/models/__init__.py"
      content: |
        from .${snake} import ${pascal}
    - path: "src/domain/repositories/${snake}.py"
      content: |
        from src.databases import Session
        from src.databases import postgres
        from src.domain import exceptions
        from src.domain import models

        from .base import Repository

        class ${pascal}(Repository):
          orm = postgres.${pascal}
          model = models.${pascal}
          error = exceptions.${pascal}NotFoundError
    - path: "src/domain/repositories/__init__.py"
      content: |
        from .${snake} import ${pascal}
    - path: "src/domain/services/${snake}.py"
      content: |
        from src.databases.postgres import pgconnect
        from src.domain import models
        from src.domain import repositories
        from src.domain import exceptions

        class ${pascal}:
            @classmethod
            async def search(cls, filters: dict, sorting: dict, pagination: dict) -> models.${pascal}:
                async with pgconnect() as session:
                    return await repositories.${pascal}.paginated(session, filters, sorting, pagination)

            @classmethod
            async def page(cls, ${snake}_id: int) -> models.${pascal}:
                async with pgconnect() as session:
                    return await repositories.${pascal}.relations(session, id=${snake}_id)

            @classmethod
            async def create(cls, ${snake}_id: int) -> models.${pascal}:
                async with pgconnect(transaction=True) as session:
                    try:
                        ${snake} = await repositories.${pascal}.one(session, id=${snake}_id)
                    except exceptions.${pascal}NotFoundError:
                        ${snake} = await repositories.${pascal}.create(
                            session,
                            model=models.${pascal}.init(id=${snake}_id),
                        )
                return ${snake}

            @classmethod
            async def delete(cls, ${snake}_id: int) -> None:
                async with pgconnect(transaction=True) as session:
                  if await repositories.${pascal}.exists(session, id=${snake}_id):
                     await repositories.${pascal}.delete(session, id=${snake}_id)

            @classmethod
            async def exists(cls, ${snake}_id: int) -> bool:
                async with pgconnect() as session:
                    return await repositories.${pascal}.exists(session, id=${snake}_id)

            @classmethod
            async def update(cls, ${snake}_id: int) -> None:
                async with pgconnect(transaction=True) as session:
                    return await repositories.${pascal}.update(session, id=${snake}_id)
    - path: "src/domain/services/__init__.py"
      content: |
        from .${snake} import ${pascal}
    - path: "src/databases/postgres/crud/${snake}.py"
      content: |
        from src.databases.postgres import tables

        from .base import CRUD

        class ${pascal}(CRUD):
            table = tables.${pascal}
    - path: "src/databases/postgres/crud/__init__.py"
      content: |
        from .${snake} import ${pascal}
    - path: "src/databases/postgres/tables/${snake}.py"
      content: |
        from sqlalchemy import BigInteger
        from sqlalchemy import Column

        from src.databases.postgres.setup import Table

        class ${pascal}(Table):
            __tablename__ = "${snake}"
            id = Column(BigInteger, primary_key=True)

    - path: "src/databases/postgres/tables/__init__.py"
      content: |
        from .${snake} import ${pascal}







alembic:
  init: "src/databases/postgres/migrations"
uv:
  main:
    - fastapi
    - alembic
    - sqlalchemy
    - uvicorn
    - asyncpg
    - pydantic
    - pydantic-settings
    - python-multipart
    - psycopg2
    - typer
  lints:
    - mypy
    - ruff
    - isort
  tests:
    - pytest
    - pytest-asyncio
    - radon
    - faker
